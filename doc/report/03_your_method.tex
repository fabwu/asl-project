\section{Methodology}\label{sec:yourmethod}

In this section we define the scope of our implementation, describe the baseline
implementation and its bottlenecks and outline the steps which were followed to
increase the performance. At the end the remaining performance blockers.

\mypar{Basic implementation}
The baseline is written from scratch in C using an iterative quadtree approach.

Algorithm \ref{alg:baseline} illustrates the compression of the algorithm, whose inputs are the image (row-wise array of doubles) of size $S \times S$,
the max quadtree depth $m$ and the error threshold $\epsilon$.\\
The function \textsc{partition($image$,$s$)} partitions the image into contiguous non-overlapping blocks of size $s \times s$.
The function \textsc{quad($R_i$, $s$)} takes a range block of size $s \times s$ and partitions it into 4 smaller range blocks.
The function \textsc{compute($image$,$R_i$, $D_i$)} computes a transformation with and the resulting RMS according to section \ref{sec:background}. 
Note that the function implicitly rotates the domain block, i.e. the function looks at the four possible locations and returns the transformation with the smallest error.
\begin{algorithm}
\caption{Compression using iterative quadtree}\label{alg:baseline}
\hspace*{\algorithmicindent} \textbf{Input:} $img$ (image of size $S \times S$), $\epsilon$ (RMS threshold) \\
\hspace*{\algorithmicindent} \textbf{Output:} $\boldsymbol{T}$ (set of computed transformations)
\begin{algorithmic}[1]
  \State $\boldsymbol{T} \gets \{\}$ \Comment{Learned transformations} 
  \State $\boldsymbol{R} \gets \Call{partition}{img, S/2}$ \Comment{Initial range blocks} 
    \For{$c=1..m$} \Comment{$c$ is the current quadtree depth}
        \State $\boldsymbol{D} \gets \Call{partition}{img, S/2^{c-1}}$
        \For{$R_i \in \boldsymbol{R}$}
            \State $err_i \gets \infty, T_i \gets \NULL$
            \For{$D_i \in \boldsymbol{D}$}
              \State $T_x, err_x \gets $ \Call{compute}{$img$, $D_i$, $R_i$}
              \If{$err_x < err_i$}
                \State $T_i \gets T_x$
                \State $err_i \gets err_x$
              \EndIf
            \EndFor
        \EndFor
        \State $\boldsymbol{R} \gets \boldsymbol{R} \backslash  R_i$ \Comment{Remove $R_i$ from $\boldsymbol{R}$}
        \If{$err_i > \epsilon$}
          \State $\boldsymbol{R} \gets \boldsymbol{R} \cup  \Call{quad}{R_i, S/2^c}$
        \Else
          \State $\boldsymbol{T} \gets \boldsymbol{T} \cup \{T_i\}$
        \EndIf
    \EndFor
\end{algorithmic}
\end{algorithm}

In order to see if our baseline achieves a reasonable performance, we compared it with
a popular C\texttt{++} implementation from GitHub \cite{github-cpp}. We used the same infrastructure to benchmark
the C\texttt{++} code and our baseline performed slightly better (see !!!ADD LINE TO PERFORMANCEPLOT!!!).

\mypar{Scope} For our implementation only square grayscale images with a power
of two width and height were considered. The reason for the restriction on the
size is that it simplifies \textit{Quadtree Partitioning}. If the width of a
range block is a power of two and no suitable transformation is found for it,
then the four new range blocks created by dividing the original range block into
4 equal parts will also have a power of two width. Colored images can be
compressed and decompressed in the same manner as grayscale images.

\notepascal{are we sure about the color stuff?}

\mypar{Roofline} We used the roofline model \cite{applying-roofline} to see whether the algorithm is memory or
compute bound. The peak performance $\pi$ was determined by counting the dispatch
ports specified in the manual \cite{intel-opt-manual}. We distinguish between scalar and vectorized peak
performance. The bandwidth $\beta$ was measured with the STREAM benchmark \cite{stream}. We verified both the peak
performance and the bandwidth with the Empirical Roofline Tool \cite{ert}, which confirmed the values.

For the program model, we need to measure the work $W$, the runtime $T$ and the data move movement $Q$ of
the algorithm. As the decisions made by the quadtree algorithm differ from image to image, the program
model depends not only on the size but also on the content of an image. Therefore, we define the three 
quantities as $W=W(S, img)$, $T=T(S, img)$ and $Q=Q(S, img)$, where $S$ and $img$ are define as in 
\ref{alg:baseline}. We measured $W$ by instrumenting the code according to the cost metric \ref{eq:cost}.
For measuring $T$, we used the \texttt{RDTSC} instruction available on all x86 architecture and disabled
Turbo Boost to guarantee an integer runtime. The measurement of $Q$ is the most challenging and requires
performance counters which are not supported by our hardware. Thus, we assumed that the image has to be
loaded at least once so we derived a very optimistic lower bound of $Q \geq 8 \cdot S^2$.

To place the baseline in the roofline plot, we calculated the \textit{operational intensity}
$$
I=\frac{W}{Q}
$$
and the \textit{performance}
$$P=\frac{W}{T}$$
of our implementation. Figure \ref{fig:roofline} shows the 
roofline plot. One can see that the baseline is inherently compute bound and we have good potential for
performance improvement as the baseline runs only at 12.5\% of scalar peak performance. Next, we use 
profiling to find the performance bottlenecks of the code.

\begin{figure}
  \includegraphics[page=1, width=.45\textwidth]{roofline}
  \caption{Roofline plot for the baseline and various performance optimizations}
  \label{fig:roofline}
\end{figure}


\mypar{Profiling} With Valgrind's callgrind and cachegrind

\mypar{Bandwidth and Data Transfer}
\mypar{Scalar Optimizations}

\mypar{Vector Optimizations}

\mypar{Block Rotations}

\mypar{Strided Access}
